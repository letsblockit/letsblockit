// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.0
// source: qLists.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countListsForUser = `-- name: CountListsForUser :one
SELECT COUNT(*)
FROM filter_lists
WHERE user_id = $1
`

func (q *Queries) CountListsForUser(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRow(ctx, countListsForUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createListForUser = `-- name: CreateListForUser :one
INSERT INTO filter_lists (user_id)
VALUES ($1)
RETURNING token
`

func (q *Queries) CreateListForUser(ctx context.Context, userID string) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createListForUser, userID)
	var token uuid.UUID
	err := row.Scan(&token)
	return token, err
}

const getListForToken = `-- name: GetListForToken :one
SELECT fl.id,
       fl.user_id,
       fl.downloaded_at,
       (SELECT max(coalesce(fi.updated_at, fi.created_at))
        from filter_instances fi
        where fi.list_id = fl.id) as last_updated
FROM filter_lists fl
WHERE token = $1
LIMIT 1
`

type GetListForTokenRow struct {
	ID           int32
	UserID       string
	DownloadedAt pgtype.Timestamptz
	LastUpdated  interface{}
}

func (q *Queries) GetListForToken(ctx context.Context, token uuid.UUID) (GetListForTokenRow, error) {
	row := q.db.QueryRow(ctx, getListForToken, token)
	var i GetListForTokenRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DownloadedAt,
		&i.LastUpdated,
	)
	return i, err
}

const getListForUser = `-- name: GetListForUser :one
SELECT token,
       downloaded_at,
       (SELECT COUNT(*) FROM filter_instances WHERE filter_instances.user_id = $1) AS instance_count
FROM filter_lists
WHERE filter_lists.user_id = $1
LIMIT 1
`

type GetListForUserRow struct {
	Token         uuid.UUID
	DownloadedAt  pgtype.Timestamptz
	InstanceCount int64
}

func (q *Queries) GetListForUser(ctx context.Context, userID string) (GetListForUserRow, error) {
	row := q.db.QueryRow(ctx, getListForUser, userID)
	var i GetListForUserRow
	err := row.Scan(&i.Token, &i.DownloadedAt, &i.InstanceCount)
	return i, err
}

const markListDownloaded = `-- name: MarkListDownloaded :exec
UPDATE filter_lists
SET downloaded_at = NOW()
WHERE token = $1
`

func (q *Queries) MarkListDownloaded(ctx context.Context, token uuid.UUID) error {
	_, err := q.db.Exec(ctx, markListDownloaded, token)
	return err
}

const rotateListToken = `-- name: RotateListToken :exec
UPDATE filter_lists
SET token      = gen_random_uuid(),
    downloaded_at = NULL
WHERE user_id = $1
  AND token = $2
`

type RotateListTokenParams struct {
	UserID string
	Token  uuid.UUID
}

func (q *Queries) RotateListToken(ctx context.Context, arg RotateListTokenParams) error {
	_, err := q.db.Exec(ctx, rotateListToken, arg.UserID, arg.Token)
	return err
}
